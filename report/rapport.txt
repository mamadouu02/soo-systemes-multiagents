Balls

On a créé une classe Balls qui contient la liste des balles (stockée sous forme de points) ainsi que leurs positions initiales. On a écrit des méthodes classiques sur Balls comme par exemple accéder au nombre de balles, définir les coordonnées des balles, mais aussi une méthode transaltion, et reInit qui replace les balles à leurs positions initiales.

Ensuite on a testé notre classe en prenant 3 balles et en essayant de les translater. On a évidemment aussi essayé, une fois déplacées, de replacer les balles à leurs positions initiales.








BallsSimulator

Pour cette classe qui implémente Simulable, on a définit comme attribut balls de type Balls qui contient donc la positions actuelles et initiales des balles. On a aussi comme attribut la liste dir des vecteurs vitesses de ces balles, insi que dir_init qui correspond aux vitesses intiales. Ainsi quand on va replacer les balles au centre on va bien pouvoir à la fois les remettre à leurs positions initiales, tout en ayant les mêmes vitesses initiales. On ajoute aussi window histoire de pouvoir dessiner. On ajoute width, height et colors car on les utilise dans notre algorithme même si je pense qu’ils ne sont pas indispensables mais cela facilite notre algorithme. On définit ensuite comme demandé les méthodes next et restart on faisait bien attention de bien recalculer les nouvelles positions et vitesses des balles. Et on fait attention à bien reset la window avant de redessiner.

Ensuite on teste notre classes en créant 6 balles et on essayant de lancer la simulation.











Conway

On créé tout d’abord une classe Cellule qui nous donne le nombre d’états possibles de la cellule en question, et son état actuel. On le fait car on voit que dans le prochain jeu on en aura besoin. Ici, comme la cellule ne peut être que vivante ou morte, on a donc que deux états. Ensuite, on créé notre classe Grille qui implémente Simulable et qui va stocker la grille en cours, et la prochaine. Cela permet que lors du calcul de la prochaine grille, on tient bien en compte des anciennes cellules, et qu’on ne prenne donc pas en compte une nouvelle. Cela n’aurait pas été possible si l’on écrasait directement la valeur. On stocke aussi la grille initiale, histoire de pouvoir revenir au cas initial tranquillement. Enfin, on a aussi la taille n, m et la window en attribut (pour pouvoir dessiner toujours). On définit les méthodes dessiner, next et restart. Dessiner et next sont en abstract car on va les écrire spécifiquement en fonction du jeu (Conway ou Immigration).
Dans le cas du jeu Conway, on extende la classe Grille en écrivant dessiner. Pour cela on parcourt toute la grille et on change juste la couleur du rectangle affiché en fonction de l’état de la cellule (morte ou vivant). Pour la méthode next, on parcourt aussi toute la grille mais on fait bien attention à placer la nouvelle valeur calculée dans grilleApres, histoire que grilleAvant ne soit pas modifié lors du calcul. On raisonne avec des modulos pour traiter le cas des bords. Ce n’est qu’à la fin de tous les calculs qu’on va recopier la grilleApres dans la grilleAvant : dans notre cas on le fait au tout début de la fonction dessiner.

On teste notre classe avec une grille de taille 10*10.








Immigration

C’est exactement le même principe que précedemment sauf qu’au lieu d’avoir seulement 2 états par Cellule, on en a n. Le seul changement est qu’on stocke le nombre d’états car on l’utilise dans la méthode next.

On teste aussi notre classe avec une grille de taille 10*10, et on peut prendre 5 états par exemple.









Schelling

Cette classe est comme précedemment un extend d’une grille, sauf qu’on ajoute comme attribut une file qui contient l’ensemble des habitations vacantes. On a aussi besoin d’une file temporaire tmp. En effet, lorsqu’on va calculer la prochaine file d’habitations vacantes, on a besoin de stocker dans tmp les habitations qui ont été quittées, et qui donc sont devenus libres. On considère qu’une habitation laissée libre ne peut pas directement être habitée, on doit attendre un tour. Ainsi, les habitations qui vont être quittées vont être mises dans tmp pour ne pas qu’elle puisse être habitées directemetn (ce qui aurait été le cas si on la mettait dans la file des habitations vacantes). On va bien évidemment supprimer une habitation vacante de la file pour que la nouvelle habitation puisse y habiter. Ce n’est qiu’à la toute fin, qu’on va remettre tous les élements de tmp dans la file des habitations vacantes histoire qu’elles puissent être habitées à partir du prochain tour.
Lors de notre calcul pour savoir si une habitation va déménager ou non, on a besoin de compter le nombre de couleurs différentes (sans les doublons évidemment), donc on choisit la collection Set (pour qu’on puisse manipuler des ensembles).
On précise aussi, que s’il y a n couleurs, il y aura n+1 états (0 pour une habitation non habitée, et enfin de 1 à n pour les n couleurs).

On teste notre classe avec 4 états (3 couleurs, et habitation vide) et K=2  (seuil).
